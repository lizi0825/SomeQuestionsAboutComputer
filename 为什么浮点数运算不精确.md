## 一些关于浮点运算的示例

### 1. 单精度与双精度的计算
```  java
class Main{
    public static void main (String[ ] args){
        float a = 0.125f;
        double b = 0.125d;
        System.out.printIn((a - b) == 0.0);
    }
}
```
输出结果是什么？

![浮点数计算1](picture\float1.png)

原因：0.125f和0.125d不存在精度损失。

### 2. double计算一定准确吗？
``` java
class Main{
    public static void main (String[] args)
    {
        double c = 0.8;
        double d = 0.7;
        double e = 0.6;
        System.out.printIn((c - d) == (d - e));
    }
}
```
c-d与d-e的结果相等吗？

![浮点数计算2](picture\float2.png)

原因：浮点数无法精确表示，存在精度损失。

### 3. 除0会抛出异常吗？
``` java
class Main{
    public static void main (String[] args)
    {
        System.out.printIn(1.0 / 0);
    }
}
```
程序会抛出异常吗？

![浮点数计算3](picture\float3.png)

原因：float、double数据类型支持无穷大。

``` java
class Main{
    public static void main (String[] args)
    {
        System.out.printIn(0.0 / 0.0);
    }
}
```
程序会抛出异常吗？

![浮点数计算4](picture\float4.png)

原因：double源码定义
``` java
public static final double POSITIVE_INFINITY = 1.0 / 0.0;
/**
 * 一个常数，保持类型的负无穷大 
*/
public static final double NEGATIVE_INFINITY = -1.0 / 0.0;
/** 
  * 一个常数,非数值类型 
*/
public static final double NaN = 0.0d / 0.0;
```
----

##  计算机中的数据表示方法

### 示例
* 在Chrome中的Console里，键入表达式`0.1+0.2`，键入回车

* 结果显示是`0.30000000000000004`

* ![Chrome console结果](picture/chrome_float_cal.png)

### $IEEE754$

#### 浮点数的一般格式
`IEEE754`浮点标准指定浮点的二进制表示格式如下，
![32位浮点](/picture/Float_example.png)
* 浮点：浮点数的符号（1bit），0表示正，1表示负。
* 指数：以2为基数（8bit）置于指数字段中的值。
* 分数：一般在0到1之间的值，放在分数字段（23bit）中。
* 从编码通过以下公式计算表示数值。
$$(-1)^{sign}×(1+fraction)×2^{exponent - 127}$$

#### 常用格式
`IEEE754`规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。其中最常用的就是32位单精度浮点数和64位双精度浮点数。

单精度浮点数在计算机存储器中占用4个字节（32 bits）
双精度浮点数(double)使用 64 位（8字节） 来存储一个浮点数

| 格式 | 单精度 | 双精度 |
| :----: | :----: | :----:|
| 指数域(E) | 8 bit | 11 bit |
| 尾数域(f) | 23 bit | 52 bit |
| 有效位数 | 24 bit | 53 bit |
| 移码偏移值（bias）| 127 | 1023 |
| 规范化E的最大值 | 127 （全1是特殊值）| 1023（全1是特殊值） |
| 规范化E的最小值 | -126（全0是特殊值）| -1022（全0是特殊值） |
| 最小正规范数 | $1.175×10^{-38}$ | $2.225×10^{-308}$ |
| 最大正规范数 | $3,402×10^{38}$ | $1.797×10^{308}$ |

#### 特殊值

* 非规范化数（Denormalized Number）
    + 定义：指数域全0，尾数域不为0（即去掉隐含整数域为1的约定）
    + 意义：可以保存绝对值更小的数，所有可以表示的浮点数的差值都可以表示

* $±0$
    + 定义：指数域全0，尾数域全0（去掉隐含整数域为1的约定）。
    + 意义：在涉及无穷的运算中避免丢失符号信息。如$\dfrac{1}{\dfrac{1}{x}}=x$，如果0不区分正负，在$x=±∞$时不成立。

* $±∞$
    + 定义：指数域全1，尾数全0
    + 意义：用于表达计算中产生的上溢（overflow），使得计算中出现上溢不止于终止计算，
    + 产生：除了NaN外的非零值除以0，其结果为正负无穷。

* NaN（Not a Number）
    + 定义：指数域全1，尾数域不为0
    + 意义：表示计算中的错误情况，例如$\dfrac{0.0}{0.0}$，使得计算中出现错误不止于终止计算
    + 特点：NaN是无序的，比较操作符在任一操作数为NaN是为false，!=在任一操作数为NaN时为true，这意味着NaN != NaN.


### 计算机表示实数的步骤

* 将实数转化为二进制格式
    + 这个步骤可能损失精度，换句话说，有些数会损失精度，而有些数不会，**这取决于表示这个数所需要的信息量和浮点数的存储格式**
* 将二进制转换为科学计数法表示
* 转换为`IEEE754`标准格式
    + 大于浮点数可以表示的最大绝对值：上溢（溢出到$±∞$）
    + 小于浮点数可以表示的最小绝对值：下溢（溢出到$±0$）
    + 尾数有效位数超过尾数域位数（另外还有隐含的整数位1）：舍入误差

## 为什么浮点数计算不准确？

### 浮点数的精度有限

* 例如，1.0（十进制）编码为$00111111100000000000000000000000$
    + 即$$0(sign)01111111(exponent)00000000000000000000000(fraction)$$
通过转换公式计算二进制数，得到结果$$1.000000000000000000000000(binary) × 2^{0}$$